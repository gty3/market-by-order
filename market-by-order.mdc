---
description: Guidelines and context for the market-by-order repository which houses public-facing trading algorithms
globs: ["market-by-order/**/*.{ts,js}"]
related_docs: ["trading-demo/nextjs/components/dom/domClient.tsx"]
---

# Market By Order Repository Guidelines

@context {
    "type": "implementation",
    "purpose": "public_trading_algorithms",
    "format_version": "1.0.0",
    "execution_context": "domClient editor"
}

## Overview

This repository contains public-facing trading algorithms that can be used within the DOM trading interface. The code here is executed in real-time within the editor component of domClient.tsx.

## Implementation Rules

@rules [
    {
        "id": "performance",
        "severity": "error",
        "description": "Code must be optimized for high-frequency execution as it runs on every market data message"
    },
    {
        "id": "state_access",
        "severity": "info",
        "description": "Trading algorithms have access to the current market state via the 'state' object"
    },
    {
        "id": "trading_functions",
        "severity": "info",
        "description": "Use placeLimitOrder and placeMarketOrder functions for executing trades"
    },
    {
        "id": "safety",
        "severity": "error",
        "description": "Include appropriate safety checks and risk management logic in all trading algorithms"
    }
]

## State Interface

@state_interface {
    "mbp10": {
        "description": "Market by price data with 10 levels of depth",
        "structure": {
            "levels": "Array of price levels with bid_px and ask_px"
        }
    },
    "userTrade": {
        "description": "Current user's active trade position",
        "structure": {
            "side": "Bid | Ask",
            "price": "number",
            "quantity": "number"
        }
    },
    "bidLimitOrder": {
        "description": "Current active bid limit order",
        "type": "object | null"
    },
    "offerLimitOrder": {
        "description": "Current active offer limit order",
        "type": "object | null"
    }
}

## Trading Functions

@trading_functions {
    "placeLimitOrder": {
        "parameters": {
            "type": "Bid | Ask",
            "price": "number",
            "stoploss": "number (optional)"
        },
        "description": "Places a limit order at the specified price"
    },
    "placeMarketOrder": {
        "parameters": {
            "type": "Buy | Sell"
        },
        "description": "Places a market order at the current best price"
    }
}

## Best Practices

@best_practices [
    {
        "id": "state_validation",
        "practice": "Always check current position before placing new orders",
        "example": "if (!state.userTrade) { ... }"
    },
    {
        "id": "risk_management",
        "practice": "Include stoploss parameters in limit orders",
        "example": "placeLimitOrder({ type: 'Bid', price: price, stoploss: 4 })"
    },
    {
        "id": "performance_optimization",
        "practice": "Minimize complex calculations in the main execution loop",
        "example": "Use simple price level comparisons instead of complex indicators"
    },
    {
        "id": "error_handling",
        "practice": "Implement proper error handling for all trading operations",
        "example": "Check for valid price levels before placing orders"
    }
]

## Example Implementation

@example {
    "type": "basic_trading_algorithm",
    "description": "Simple market making strategy"
}

```typescript
// Basic market making strategy
const ask1 = state.mbp10.levels[1].ask_px
const bid1 = state.mbp10.levels[1].bid_px

// If not currently in a trade
if (!state.userTrade) {
    if (!state.bidLimitOrder) {
        placeLimitOrder({
            type: "Bid",
            price: bid1,
            stoploss: 4
        })
    } else if (!state.offerLimitOrder) {
        placeLimitOrder({
            type: "Ask",
            price: ask1,
            stoploss: 4
        })
    }
}
```

## Security Considerations

@security {
    "code_review": "All algorithms must be reviewed for potential security issues",
    "risk_limits": "Implement appropriate position and loss limits",
    "error_handling": "Proper error handling to prevent unexpected behavior",
    "data_validation": "Validate all market data before use in calculations"
}

## Performance Guidelines

@performance {
    "execution_frequency": "Code runs on every market data message (up to 2000 times per second)",
    "optimization_requirements": [
        "Minimize complex calculations",
        "Avoid unnecessary object creation",
        "Use simple conditional logic",
        "Minimize array operations"
    ]
} 